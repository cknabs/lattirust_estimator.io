<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Lattice reduction
  #

Lattice reduction algorithms such as LLL and BKZ make iterative local improvements to a basis. This means that the global cost can be seen as two-folds: how costly is it to make the local improvements, which corresponds to solving an exact SVP problem and how costly is the global behavior of the algorithm. This section focuses on the global behavior of lattice reduction algorithms, while the next section (Cost models) will focus about solving local improvements. Lattice reduction is the essential tool that allows to transform an inappropriate basis to solve the SIS problem into an appropriate one and thus its complexity is the bulk of the security estimate.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/lattice-reduction/">
  <meta property="og:site_name" content="Lattirust estimator 0.1">
  <meta property="og:title" content="Lattice reduction">
  <meta property="og:description" content="Lattice reduction#Lattice reduction algorithms such as LLL and BKZ make iterative local improvements to a basis. This means that the global cost can be seen as two-folds: how costly is it to make the local improvements, which corresponds to solving an exact SVP problem and how costly is the global behavior of the algorithm. This section focuses on the global behavior of lattice reduction algorithms, while the next section (Cost models) will focus about solving local improvements. Lattice reduction is the essential tool that allows to transform an inappropriate basis to solve the SIS problem into an appropriate one and thus its complexity is the bulk of the security estimate.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">
<title>Lattice reduction | Lattirust estimator 0.1</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/lattice-reduction/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.95ba0023c63c0960b8b4f53e911d9e59cbf863fd6127a49489e0e10b31c9d4c4.js" integrity="sha256-lboAI8Y8CWC4tPU&#43;kR2eWcv4Y/1hJ6SUieDhCzHJ1MQ=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/docs/lattice-reduction/index.xml" title="Lattirust estimator 0.1" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<link rel="stylesheet" type="text/css" href="http://localhost:1313/scss/hugo-simplecite.min.138dd14c6aaf1b1a9b55c4fe22f82166812ce8081413d67a3b464e411d2b63ef.css">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Lattirust estimator 0.1</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/preliminaries/" class="">Preliminaries</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/lattice-reduction/" class="active">Lattice reduction</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/cost-models/" class="">Cost Models</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/sis/" class="">SIS</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>SIS variants</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/basis/" class="">Basis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/isisf/" class="">Isisf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/kmsis/" class="">Kmsis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/krisis/" class="">Krisis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/ksis/" class="">Ksis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/module-sis/" class="">Module Sis</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/prisis/" class="">Prisis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis-variants/ring-sis/" class="">Ring Sis</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/searching/" class="">Searching for the right parameters</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Lattice reduction</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#useful-quantities-in-lattices">Useful quantities in lattices</a>
      <ul>
        <li><a href="#volume">Volume</a></li>
        <li><a href="#gaussian-heuristic">Gaussian heuristic</a></li>
        <li><a href="#root-hermite-factor">Root Hermite Factor</a></li>
        <li><a href="#geometric-series-assumption">Geometric Series Assumption</a></li>
      </ul>
    </li>
    <li><a href="#lll-algorithm">LLL algorithm</a>
      <ul>
        <li><a href="#cost-of-lll">Cost of LLL</a></li>
      </ul>
    </li>
    <li><a href="#bkz-algorithm">BKZ algorithm</a>
      <ul>
        <li><a href="#cost-of-bkz">Cost of BKZ</a></li>
        <li><a href="#bkz-20-tweaks">BKZ 2.0 Tweaks</a></li>
        <li><a href="#the-lie-of-the-gsa-assumption-and-better-simulators-zgsa">The Lie of the GSA Assumption and Better Simulators (ZGSA)</a></li>
        <li><a href="#the-dimension-for-free-ducas">The Dimension for Free (Ducas)</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="lattice-reduction">
  Lattice reduction
  <a class="anchor" href="#lattice-reduction">#</a>
</h1>
<p>Lattice reduction algorithms such as LLL and BKZ make iterative local improvements to a basis. This means that the global cost can be seen as two-folds: how costly is it to make the local improvements, which corresponds to solving an exact SVP problem and how costly is the global behavior of the algorithm. This section focuses on the global behavior of lattice reduction algorithms, while the next section (Cost models) will focus about solving local improvements. Lattice reduction is the essential tool that allows to transform an inappropriate basis to solve the SIS problem into an appropriate one and thus its complexity is the bulk of the security estimate.</p>
<h2 id="useful-quantities-in-lattices">
  Useful quantities in lattices
  <a class="anchor" href="#useful-quantities-in-lattices">#</a>
</h2>
<h3 id="volume">
  Volume
  <a class="anchor" href="#volume">#</a>
</h3>
<p>In each lattice, we can define the volume of the lattice as the volume of its fundamental parallellepiped (the area delimited by the basis vectors). This quantity is an invariant of the lattice and does not depend on the basis chosen. This means that by applying Gram-Schmidt orthogonalization to any basis will give us an orthogonal basis from which we can approximate the volume of the lattice as</p>
$$ Vol(\Lambda) =  \prod_{i=0}^{d-1} \lVert \bold{b_i}^*\rVert $$<p>where $\bold{b_i}*$ are the orthogonal Gram-Schmidt vectors. It is also important to remember that $Vol(\Lambda) = |Det(\bold{B})|$, where $\bold{B}$ is the basis matrix.</p>
<p><img src="volume.png" alt="alt text" /></p>
<p>This invariant is conceptually important because it tells us that not all basis vectors can be small at the same time.</p>
<h3 id="gaussian-heuristic">
  Gaussian heuristic
  <a class="anchor" href="#gaussian-heuristic">#</a>
</h3>
<p>The gaussian heuristics predicts the number of lattice points inside any measurable body $\mathcal{B} \subset \mathbb{R}^d$ is approximately $\frac{Vol(\mathcal{B})}{Vol(\Lambda)}$. Applied to an euclidean d-ball, this would give that the length of the first vector is approximately</p>
$$\lambda_1(\Lambda) \approx (\frac{Vol(\mathcal{B})}{Vol(\Lambda)})^{\frac{1}{d}} \approx \sqrt{\frac{d}{2\pi e}} Vol(\Lambda)^{\frac{1}{d}}$$<h3 id="root-hermite-factor">
  Root Hermite Factor
  <a class="anchor" href="#root-hermite-factor">#</a>
</h3>
<p>We will next want to introduce a value called the <em>root hermite factor</em>. It is a measure used in lattice reduction theory to evaluate the quality of a reduced lattice basis. It is commonly used to assess the effectiveness of lattice reduction algorithms. It quantifies how much longer the shortest vector in a reduced lattice basis is, compared to the length of an ideal shortest vector, scaled by the lattice dimension. Formally we define it as</p>
$$\lVert \bold{b_1} \rVert \approx \delta^d Vol(\Lambda)^\frac{1}{d}$$<p> for an d-dimensional lattice.</p>
<p>The closer $\delta$ gets to 1, the better the reduction quality will be. This is of direct impact in our context, since we need to balance a trade-off between the quality of the output basis and the cost of running our lattice reduction algorithm. In fact, with the BKZ algorithm which has become the standard, a bigger block-size leads to a better quality of output basis but also a greater computational cost.</p>
<h3 id="geometric-series-assumption">
  Geometric Series Assumption
  <a class="anchor" href="#geometric-series-assumption">#</a>
</h3>
<p>The geometric series assumption conceptually tells us that the Gram-Schmidt vectors log-length outputed by a lattice reducion algorithm will follow a line (see the graphs in the LLL subsection). We can formulate it as:</p>
$$\lVert \bold{b_i}^*\rVert \approx \alpha^{i-1}\lVert \bold{b_1}\rVert$$<p>and in fact by combining it with the root hermite factor definition we can get a relation between the quality of the reduction and the slope of the GSA assumption as $\alpha \approx \delta^{-2}$ leading to</p>
$$ \lVert \bold{b_i}^*\rVert \approx \alpha^{i-1} \delta^d Vol(\Lambda)^\frac{1}{d} = \delta^{-1(i+1) + d} Vol(\Lambda)^\frac{1}{d}$$<h2 id="lll-algorithm">
  LLL algorithm
  <a class="anchor" href="#lll-algorithm">#</a>
</h2>
<p>The Lenstra-Lenstra-Lovász (LLL) algorithm is an efficient polynomial-time algorithm in lattice theory that finds a &ldquo;nearly orthogonal&rdquo; basis for a given lattice. It aims to transform any arbitrary basis of a lattice into a reduced basis where the basis vectors are short and close to orthogonal following two conditions:</p>
<ol>
<li>Size reduction:
$$1 \leq j < i \leq d\colon \left|\mu_{i,j}\right|\leq 0.5 \text{ for } \mu_{i,j} =\frac{\langle\mathbf{b}_i,\mathbf{b}^*_j\rangle}{\langle\mathbf{b}^*_j,\mathbf{b}^*_j\rangle}$$</li>
<li>Lovász condition:
For $k=2,&hellip;,d$ $$\omega \Vert \mathbf{b}^*_{k-1}\Vert^2  \leq \Vert \mathbf{b}^*_k\Vert^2+ \mu_{k,k-1}^2\Vert\mathbf{b}^*_{k-1}\Vert^2$$</li>
</ol>
<p>We say the basis is LLL-reduced if there exists a parameter $\omega \in (0.25, 1)$.</p>
<p>While there exists some theorems bounding the worst cases of lattice reduction algorithms, they tend to perform better in practice. Reasoning about the behaviors of such algorithms has therefore become a game of heuristics and approximations. Typically, the vectors that are outputed by the LLL algorithm are said to follow the geometric series assumption in their length. Again, this assumption tells us that the shape after lattice reduction is a line with a flatter slope as lattice reduction gets stronger. The goal of lattice reduction algorithm can therefore be interpreted seen by watching a graph of the log-length of vectors after reductions. The overall goal being to flatten the line, leading to a small basis.</p>
<p><img src="before_LLL.png" alt="alt text" /></p>
<p><img src="after_LLL.png" alt="alt text" /></p>
<h3 id="cost-of-lll">
  Cost of LLL
  <a class="anchor" href="#cost-of-lll">#</a>
</h3>
<p>The theoretic bound on the quality of the LLL is $\delta^d = (\frac{4}{3})^\frac{d-1}{4}$ leading to approximately $\delta \approx 1.075$. In practice, we get much better results on average, empirically about $\delta \approx 1.021$.</p>
<p>In terms of runtime, we will consider a heuristic bound (which better approximates empirical results) of $O(d^3 \log^2(B))$.</p>
<h2 id="bkz-algorithm">
  BKZ algorithm
  <a class="anchor" href="#bkz-algorithm">#</a>
</h2>
<p>The Block Korkine-Zolotarev (BKZ) algorithm is a lattice reduction algorithm that generalizes the LLL algorithm to achieve stronger reduction properties. The BKZ algorithm is defined as a blockwise reduction algorithm that iteratively applies a form of lattice basis reduction to overlapping blocks of vectors within the basis. Assuming we have an SVP oracle, the BKZ algorithm is defined as follows:</p>
<pre><code>Data: LLL-reduced basis B (pre-processed) and block size beta
repeat until no changes
    for k in 0 to d-1
        LLL on local projected block [k, ..., k+beta-1]
        v &lt;-- SVP-Oracle(local projected block[k, ..., k+beta-1])
        insert v into B
    end
</code></pre>
<p>A BKZ-$\beta$ reduced basis satisfies, for $\epsilon &gt; 0$:</p>
$$\lVert \bold{b_0} \rVert \leq \sqrt{(1 + \epsilon) \gamma_{\beta}}^\frac{d-1}{\beta - 1} Vol(\Lambda(\bold{B}))$$$$\gamma_\beta =  \sup \{ \lambda_1(\Lambda) | \Lambda \in \mathbb{R}^\beta, Vol(\Lambda) = 1 \}$$<p>is the hermite constant.</p>
<p>By combining the gaussian heuristic and the definition of a BKZ-$\beta$ reduced basis, we arrive again at the geometric assumption, which states that the length of reduced vectors follow a geometric series (which we can plot as a line as we did for LLL). This time however, it depends on the block-size chosen to run BKZ.</p>
<p>We can write</p>
$$\log(\lVert \bold{b_i}^*\rVert) = \frac{d - 1 - 2i}{2}\log(\alpha_\beta) + \frac{1}{d}\log(Vol(\Lambda))$$<p>where $\alpha_\beta$ is the slope under the geometric assumption that can be calculated from the gaussian assumption as</p>
$$\alpha_\beta = \sqrt{\frac{d}{2\pi e}}^\frac{2}{\beta - 1}$$<p>This estimate is reasonably accurate only if $d\gg\beta$ and $\beta &gt; 50$, which is why we will use fixed estimates for small dimensions.</p>
<h3 id="cost-of-bkz">
  Cost of BKZ
  <a class="anchor" href="#cost-of-bkz">#</a>
</h3>
<ul>
<li>Costing BKZ means having a good idea of the impact of the block-size on the quality of our reduced basis. For this, we could either make the approximation $\delta_\beta \approx \sqrt \alpha_\beta$ or use the following limit defined in
$$\lim_{\beta\rightarrow\infty}\delta_\beta = (\frac{\beta}{2\pi e}(\pi\beta)^\frac{1}{\beta})^\frac{1}{2(\beta - 1)}$$</li>
</ul>
<p>and write for SIS</p>
$$\lVert \bold{b_1} \rVert \approx \delta_\beta^{d-1} Vol(\Lambda)^{\frac{1}{d}}$$<ul>
<li>Costing BKZ as a whole is complicated because we do not know how many tours we will have to run, which means we don&rsquo;t really know in advance the number of SVP-Oracle calls we will have to make. Furthermore, many improvements on plain BKZ have been made when some techniques are used as a subroutine for the oracle (for example extreme pruning in the context of enumeration), which makes security estimates done via lattice reduction very sensitive to many factors. Also, local preprocessing techniques in a variant of BKZ known as progressive BKZ. To make our tool comparable to the lattice estimator by &hellip;[insert], we will follow the same simplifying assumption and consider a consistent 8 tours of BKZ. This makes sense following experimental results that showed that most progress is made in the 7-9 first tours. We will then use:
$$cost = \tau \cdot d \cdot T_{SVP}$$
where</li>
</ul>
<ol>
<li>the number of tours we do $\tau$ is considered to be 8.</li>
<li>The number of times the SVP oracle is called per tour, which is dimension of the lattice, is d</li>
<li>The cost of the SVP oracle is $T_{SVP}$</li>
</ol>
<h3 id="bkz-20-tweaks">
  BKZ 2.0 Tweaks
  <a class="anchor" href="#bkz-20-tweaks">#</a>
</h3>
<p>The BKZ 2.0 algorithm introduces several key optimizations to improve the efficiency and effectiveness of the lattice reduction process. These enhancements address both the quality of the reduced basis and the computational overhead:</p>
<ol>
<li>
<p><strong>Extreme Pruning</strong>:</p>
<ul>
<li>Extreme pruning focuses the SVP oracle&rsquo;s efforts on the most promising branches of the search space, reducing unnecessary computations. This technique significantly accelerates the oracle’s performance without compromising the output quality.</li>
</ul>
</li>
<li>
<p><strong>Adaptive Block Sizes</strong>:</p>
<ul>
<li>BKZ 2.0 dynamically adjusts the block size ($\beta$) during execution. By using smaller block sizes initially and increasing them later, the algorithm finds a better trade-off between runtime and reduction quality.</li>
</ul>
</li>
<li>
<p><strong>Improved Local Search</strong>:</p>
<ul>
<li>Advanced local search algorithms enhance the process of finding short vectors within each block. These improvements reduce the time spent on individual blocks while maintaining or improving the overall basis quality.</li>
</ul>
</li>
<li>
<p><strong>Experimental Impact</strong>:</p>
<ul>
<li>Empirical studies show that BKZ 2.0 achieves better reduction quality than the original BKZ, especially for large dimensions. It also demonstrates improved scalability and efficiency in practice.</li>
</ul>
</li>
</ol>
<h3 id="the-lie-of-the-gsa-assumption-and-better-simulators-zgsa">
  The Lie of the GSA Assumption and Better Simulators (ZGSA)
  <a class="anchor" href="#the-lie-of-the-gsa-assumption-and-better-simulators-zgsa">#</a>
</h3>
<p>The Geometric Series Assumption (GSA), while widely used, does not perfectly capture the behavior of lattice reduction algorithms. This section highlights its limitations and introduces a more accurate model, ZGSA:</p>
<ol>
<li>
<p><strong>Why GSA Falls Short</strong>:</p>
<ul>
<li>The GSA assumes that the Gram-Schmidt vector lengths decay geometrically. However, this assumption breaks down for smaller lattices or when dealing with structured lattices that deviate significantly from randomness.</li>
</ul>
</li>
<li>
<p><strong>Introduction to ZGSA</strong>:</p>
<ul>
<li>The Zero-Forced Geometric Series Assumption (ZGSA) refines the GSA by accounting for boundary effects and deviations observed in practical reductions. ZGSA provides a more precise representation of the reduced basis.</li>
</ul>
</li>
<li>
<p><strong>Comparison with GSA</strong>:</p>
<ul>
<li>Empirical results indicate that ZGSA predictions align more closely with observed reductions compared to GSA. A comparison of plots or metrics can demonstrate this improved accuracy.</li>
</ul>
</li>
<li>
<p><strong>Applications of ZGSA</strong>:</p>
<ul>
<li>ZGSA has been instrumental in refining security estimates for lattice-based cryptography, particularly in the context of parameter selection and attack simulations.</li>
</ul>
</li>
</ol>
<h3 id="the-dimension-for-free-ducas">
  The Dimension for Free (Ducas)
  <a class="anchor" href="#the-dimension-for-free-ducas">#</a>
</h3>
<p>The &ldquo;dimension for free&rdquo; concept introduced by Ducas reduces the cost of lattice reduction in high-dimensional lattices without sacrificing output quality. This approach is particularly relevant in practical implementations of lattice reduction algorithms.</p>
<ol>
<li>
<p><strong>Concept Overview</strong>:</p>
<ul>
<li>The &ldquo;dimension for free&rdquo; principle exploits structural redundancies in high-dimensional lattices, enabling efficient reductions with fewer computational resources.</li>
</ul>
</li>
<li>
<p><strong>Impact on BKZ</strong>:</p>
<ul>
<li>By incorporating the &ldquo;dimension for free,&rdquo; BKZ and BKZ 2.0 achieve improved runtime performance. This is especially beneficial in cryptographic applications requiring reductions in very high dimensions.</li>
</ul>
</li>
<li>
<p><strong>Trade-offs and Limitations</strong>:</p>
<ul>
<li>While highly effective in many cases, the &ldquo;dimension for free&rdquo; may not yield significant improvements for small lattices or those lacking sufficient dimensionality for optimization.</li>
</ul>
</li>
<li>
<p><strong>Practical Implications</strong>:</p>
<ul>
<li>The &ldquo;dimension for free&rdquo; approach has become a cornerstone of efficient lattice reduction techniques. Its adoption in lattice-based cryptography has further solidified its role in modern security parameter design.</li>
</ul>
</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#useful-quantities-in-lattices">Useful quantities in lattices</a>
      <ul>
        <li><a href="#volume">Volume</a></li>
        <li><a href="#gaussian-heuristic">Gaussian heuristic</a></li>
        <li><a href="#root-hermite-factor">Root Hermite Factor</a></li>
        <li><a href="#geometric-series-assumption">Geometric Series Assumption</a></li>
      </ul>
    </li>
    <li><a href="#lll-algorithm">LLL algorithm</a>
      <ul>
        <li><a href="#cost-of-lll">Cost of LLL</a></li>
      </ul>
    </li>
    <li><a href="#bkz-algorithm">BKZ algorithm</a>
      <ul>
        <li><a href="#cost-of-bkz">Cost of BKZ</a></li>
        <li><a href="#bkz-20-tweaks">BKZ 2.0 Tweaks</a></li>
        <li><a href="#the-lie-of-the-gsa-assumption-and-better-simulators-zgsa">The Lie of the GSA Assumption and Better Simulators (ZGSA)</a></li>
        <li><a href="#the-dimension-for-free-ducas">The Dimension for Free (Ducas)</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












