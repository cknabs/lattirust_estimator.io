<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Preliminaries
  #


  Lattices
  #

A lattice is defined as a set of points in n-dimensional space with a periodic structure. A lattice can be represented by a set of linearly independent vectors commonly named the basis of the lattice. If \(\bold{b_1}, &hellip;, \bold{b_n}\) denote basis vectors we can describe a lattice by: 
$$\Lambda(\bold{b_1}, ..., \bold{b_n}) = \{\sum_{i=1}^{n}x_i\bold{b_i}: x_i \in \mathbb{Z}\}$$
In the rest of this work, we will especially consider q-ary lattices described by a basis \(\bold{B} \in \mathbb{Z}^{h\times w}_q\), in which coefficients are taken modulo q.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/preliminaries/">
  <meta property="og:site_name" content="Lattirust estimator 0.1">
  <meta property="og:title" content="Preliminaries">
  <meta property="og:description" content="Preliminaries # Lattices # A lattice is defined as a set of points in n-dimensional space with a periodic structure. A lattice can be represented by a set of linearly independent vectors commonly named the basis of the lattice. If \(\bold{b_1}, …, \bold{b_n}\) denote basis vectors we can describe a lattice by: $$\Lambda(\bold{b_1}, ..., \bold{b_n}) = \{\sum_{i=1}^{n}x_i\bold{b_i}: x_i \in \mathbb{Z}\}$$
In the rest of this work, we will especially consider q-ary lattices described by a basis \(\bold{B} \in \mathbb{Z}^{h\times w}_q\), in which coefficients are taken modulo q.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">
<title>Preliminaries | Lattirust estimator 0.1</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/preliminaries/">
<link rel="stylesheet" href="/book.min.434035e7885c7f5d12818bd9f111cf1a0925c6fb78382667381c3d5eda3fb4f1.css" integrity="sha256-Q0A154hcf10SgYvZ8RHPGgklxvt4OCZnOBw9Xto/tPE=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.93a27f72c29d9b9146eb5841b211bc1e3345144b6d2904f397e5e0087df48f58.js" integrity="sha256-k6J/csKdm5FG61hBshG8HjNFFEttKQTzl&#43;XgCH30j1g=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/docs/preliminaries/index.xml" title="Lattirust estimator 0.1" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Lattirust estimator 0.1</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/preliminaries/" class="active">Preliminaries</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/lattice-reduction/" class="">Lattice reduction</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/cost-models/" class="">Cost Models</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/sis/" class="">SIS</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/sis/module-sis/" class="">Module Sis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/sis/ring-sis/" class="">Ring Sis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Preliminaries</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#lattices">Lattices</a>
      <ul>
        <li><a href="#the-short-vector-problem">The Short Vector Problem</a></li>
        <li><a href="#lattice-reduction-algorithms">Lattice reduction algorithms</a></li>
      </ul>
    </li>
    <li><a href="#security">Security</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="preliminaries">
  Preliminaries
  <a class="anchor" href="#preliminaries">#</a>
</h1>
<h2 id="lattices">
  Lattices
  <a class="anchor" href="#lattices">#</a>
</h2>
<p>A <em>lattice</em> is defined as a set of points in n-dimensional space with a periodic structure. A lattice can be represented by a set of linearly independent vectors commonly named the basis of the lattice. If \(\bold{b_1}, &hellip;, \bold{b_n}\) denote basis vectors we can describe a lattice by: </p>
$$\Lambda(\bold{b_1}, ..., \bold{b_n}) = \{\sum_{i=1}^{n}x_i\bold{b_i}: x_i \in \mathbb{Z}\}$$<p><img src="lattices-1.png" alt="alt text" /></p>
<p>In the rest of this work, we will especially consider q-ary lattices described by a basis \(\bold{B} \in \mathbb{Z}^{h\times w}_q\), in which coefficients are taken modulo q.</p>
<h3 id="the-short-vector-problem">
  The Short Vector Problem
  <a class="anchor" href="#the-short-vector-problem">#</a>
</h3>
<p>The security of lattice based constructions rely on the fact that finding the shortest non-zero vector in a lattice is a hard problem. One usually considers an approximation version of the SVP problem. Given a basis \(\bold{B}\) of a lattice, <em>the approximate SVP problem</em> is the problem of finding a short lattice vector \(\bold{v}\) such that \(0 &lt; \lVert \bold{v} \rVert \leq \gamma\lambda_1(\Lambda(\bold{B}))\) where \(\lambda_1\) denotes the shortest nonzero vector length and \(\gamma\) is the approximation factor.</p>
<p>It is actually believed that no polynomial time algorithm can approximate such a lattice problem within polynomial factors. Furthermore, it is also believed that no polynomial time quantum algorithm can approximate such a lattice problem within polynomial factors.</p>
<h3 id="lattice-reduction-algorithms">
  Lattice reduction algorithms
  <a class="anchor" href="#lattice-reduction-algorithms">#</a>
</h3>
<p><em>Lattice reduction algorithms</em> aim to transform a given basis of a lattice into a &ldquo;reduced&rdquo; basis, where the vectors are shorter and closer to being orthogonal. This reduction makes it easier to approximate solutions to hard lattice problems like the Shortest Vector Problem. In short, the quality of a basis can be improved to make the problem easier. The most prominent lattice reduction algorithms include:</p>
<ul>
<li><strong>LLL Algorithm (Lenstra–Lenstra–Lovász)</strong>: it produces a reduced basis in polynomial time, where the vectors are guaranteed to be within a known factor of the shortest vector, but doesn’t necessarily find the shortest vector,</li>
<li><strong>BKZ Algorithm (Block Korkine-Zolotarev)</strong>: the BKZ algorithm is a generalization of the LLL algorithm and provides better reduction at the cost of higher computational complexity. By working in blocks of the lattice and applying LLL reduction to these blocks, BKZ achieves stronger approximations of the shortest vector, though it requires more computational resources.</li>
<li><strong>Sieving and Enumeration</strong>: algorithms that are designed to give exact solutions to the SVP problem.</li>
</ul>
<h2 id="security">
  Security
  <a class="anchor" href="#security">#</a>
</h2>
<p>The foundational belief of security in new lattice-based primitives stems from one key finding. Ajtai’s theorem connected the hardness of certain average-case problems to the difficulty of worst-case problems in lattices. Specifically, Ajtai demonstrated that for the Short Integer Solution (SIS) problem which we will define later, the average-case instances are at least as hard as the worst-case instances of the Shortest Vector Problem (SVP) on lattices. This means that if one could efficiently solve random instances of SIS, then they could also solve the worst-case SVP, a problem believed to be intractable even for quantum computers. Ajtai’s theorem provides a strong security guarantee for lattice-based cryptographic schemes by grounding their security in the hardness of well-studied lattice problems like SVP.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#lattices">Lattices</a>
      <ul>
        <li><a href="#the-short-vector-problem">The Short Vector Problem</a></li>
        <li><a href="#lattice-reduction-algorithms">Lattice reduction algorithms</a></li>
      </ul>
    </li>
    <li><a href="#security">Security</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












